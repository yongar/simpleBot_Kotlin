<div class="step-text">
<p><a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a type check is the process of verifying if an object belongs to a particular data type. | This is done using the `and` operator, which allows developers to check if an object is an instance of a specific type. If the object belongs to the specified type, the `and` operator returns `true`; otherwise, it returns `false`. Type checking in Kotlin is safe and easy to use because it is a statically-typed language, and any type mismatch or compile-time errors can be detected by the programmer during the development phase.">Type checks</a> and casts are essential in any programming language. Type checks allow developers to verify if an object belongs to a particular data type, while <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, type casting is the process of converting an object from one data type to another. | It is used when working with objects of different types and performing operations that require a specific type. Kotlin, being a statically-typed language, has several features that make type checking and casting easy and safe to use. The `is` and `!is` operators in Kotlin are used for type checking. They allow developers to check if an object belongs to a particular data type. The `as` keyword is used for casting an object to a different type.">type casts</a> enable programmers to convert an object from one type to another. Kotlin, being a statically-typed language, has several features that make type checks and casts easy and safe to use.</p>
<h5 id="is-and-is-operators">is and !is operators</h5>
<p>The <code class="language-kotlin">is</code> and <code class="language-kotlin">!is</code> operators in Kotlin are used for type checks. They allow developers to check if an object belongs to a particular data type. The <code class="language-kotlin">is</code> operator returns true if an object belongs to the specified type and false if it doesn't. Conversely, the <code class="language-kotlin">!is</code> operator returns true if an object doesn't belong to the specified type and false if it does.</p>
<p>For example:</p>
<pre><code class="language-kotlin">val obj: Any = "Hello, Kotlin"
if (obj is String) {
   println(obj.uppercase())
} else {
   println("obj is not a String")
}</code></pre>
<p>In the above code, we use the <code class="language-kotlin">is</code> operator to check if the <code class="language-kotlin">obj</code> variable is a <code class="language-kotlin">String</code>. If it is a <code class="language-kotlin">String</code>, we convert it to uppercase and print it. Otherwise, we print a message saying that <code class="language-kotlin">obj</code> is not a <code class="language-kotlin">String</code>. This is a good example for the <code class="language-kotlin">is</code> operator, but let's remember the <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an idiom refers to a recommended programming practice or convention that has been endorsed by the community. | Idioms are designed to promote concise, clear, and efficient code. For example, string interpolation is an idiom that allows you to insert variable values into a string using the $ symbol followed by the variable name. Another helpful idiom is the use of the [ ] syntax to access elements in a collection, such as a list or map. This syntax is more concise and easier to read than using the get() function.">idioms</a> in Kotlin, one of the advantages of this programming language. One of the often used idioms in Kotlin is:</p>
<pre><code class="language-kotlin">when (x) {
    is Foo -&gt; ...
    is Bar -&gt; ...
    else   -&gt; ...
}</code></pre>
<p>Look at an example of how we can use that:</p>
<pre><code class="language-kotlin">fun processInput(input: Any) {
    when (input) {
        is Int -&gt; println("Input is an integer")
        is String -&gt; println("Input is a string")
        is Double -&gt; println("Input is a double")
        else -&gt; println("Unknown input")
    }
}</code></pre>
<p>In this example, the function <code class="language-kotlin">processInput</code> takes an argument of type <code class="language-kotlin">Any</code>, which means it can accept any type of object. Within the function, we use <code class="language-kotlin">when</code> with <code class="language-kotlin">is</code> to check the type of the input object. Depending on the type, we print a message indicating what type of input it is. If the input object is not one of the expected types, we print the "Unknown input" message.</p>
<h5 id="smart-casts">Smart casts</h5>
<p>Kotlin also has a feature known as <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, smart cast is a feature that simplifies code when working with nullable types. | When a nullable type is checked using the `is` operator, Kotlin automatically casts the object to a non-nullable type. This means that you don't need to use any type cast operator. Smart cast can make your code more concise and easier to read. However, it's important to note that smart cast only works when the type is checked using the `is` operator. If you need to perform a type cast in other situations, you can use the unsafe cast operator, represented by the `as?` keyword.">smart casts</a>. Smart casts are used to simplify code when working with <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a nullable type is a variable that can hold a null value, in contrast to a non-nullable type, which cannot. | This is a key feature of Kotlin's null safety, which aims to eliminate null reference errors. In Kotlin, types are non-nullable by default, and if you want to declare a variable that can hold a null value, you must append a question mark to the type. When working with nullable types, Kotlin requires you to handle the possibility of a null value explicitly, making your code safer and more predictable.">nullable types</a>. When a nullable type is checked with the <code class="language-kotlin">is</code> operator, Kotlin automatically casts the object to a <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-nullable is a type that cannot hold a null value. | Unlike Java, where all reference types can hold null values, Kotlin makes a distinction between nullable and non-nullable types. By making types non-nullable by default and providing explicit nullable types, Kotlin compels developers to handle the possibility of null values in a controlled way. This helps to reduce the risk associated with null references, often referred to as the billion-dollar mistake. Safe call and the elvis operator are two features in Kotlin that help handle nullable types securely and prevent null pointer exceptions. Safe call allows you to access properties and methods of a nullable object without the risk of a null pointer exception.">non-nullable</a> type.</p>
<p>For example:</p>
<pre><code class="language-kotlin">fun printLength(obj: Any) {
   if (obj is String) {
      println(obj.length)
   }
}</code></pre>
<p>In the above code, we check if the <code class="language-kotlin">obj</code> variable is a <code class="language-kotlin">String</code> by using the <code class="language-kotlin">is</code> operator. If it is a <code class="language-kotlin">String</code>, we print its length. Since Kotlin automatically casts the <code class="language-kotlin">obj</code> variable to a non-nullable type, we don't need to use any type cast operator.</p>
<h5 id="unsafe-cast-operator">"Unsafe" cast operator</h5>
<p>Kotlin has an unsafe cast operator, which is represented by the <code class="language-kotlin">as</code> <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a keyword is a word that has a special meaning in the language and cannot be changed by the programmer. | It is used to define the structure and behavior of the code. Examples of keywords in Kotlin include `fun` (used to define a function), `var` (used to define a variable), and `if` (used to define a conditional statement). Keywords are reserved words in Kotlin and cannot be used as identifiers.">keyword</a>. The <code class="language-kotlin">as</code> keyword is used to cast an object to a non-nullable type. If the object cannot be cast to the specified type, the <code class="language-kotlin">as</code> operator throws a ClassCastException.</p>
<p>For example:</p>
<pre><code class="language-kotlin">val obj: Any = "Hello, Kotlin"
val str: String = obj as String // Unsafe cast operator
println(str.uppercase())</code></pre>
<p>In the above code, we use the <code class="language-kotlin">as</code> operator to cast the <code class="language-kotlin">obj</code> variable to a <code class="language-kotlin">String</code>. If <code class="language-kotlin">obj</code> is not a <code class="language-kotlin">String</code>, the <code class="language-kotlin">as</code> operator throws a ClassCastException.</p>
<h5 id="safe-nullable-cast-operator">"Safe" (nullable) cast operator</h5>
<p>Kotlin also has a safe cast operator, which is represented by the <code class="language-kotlin">as?</code> keyword. The <code class="language-kotlin">as?</code> operator is used to cast an object to a nullable type. If the object cannot be cast to the specified type, the <code class="language-kotlin">as?</code> operator returns <code class="language-kotlin">null</code>.</p>
<p>For example:</p>
<pre><code class="language-kotlin">fun main() {
    val obj: Any = 123
    val str: String? = obj as? String // Safe (nullable) cast operator
    if (str != null) {
        println(str.uppercase())
    }
}</code></pre>
<p>In the above code, we use the <code class="language-kotlin">as?</code> operator to cast the <code class="language-kotlin">obj</code> variable to a <code class="language-kotlin">String</code>. Since <code class="language-kotlin">obj</code> is not a <code class="language-kotlin">String</code>, the <code class="language-kotlin">as?</code> operator returns <code class="language-kotlin">null</code>. Therefore, the <code class="language-kotlin">println</code> <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a statement is a single command to be executed, such as printing a text or assigning a value to a variable. | Unlike expressions, which produce a single value as a result of computation, statements are standalone commands that have a side effect, like changing the state of the program. The result of a statement is not used in the program, whereas the result of an expression often is. For example, in the statement `val x = 2 * 2`, the expression `2 * 2` is evaluated, and its result is assigned to the variable `x`. However, the result of the statement itself is not used in the program. In contrast, if you write `println(2 * 2)`, the expression `2 * 2` is evaluated, and its result is passed directly to the `println` function, which then prints the result. It's important to note that a statement can be an expression, but not all expressions are statements. For instance, `2 * 2` is an expression, but it's not a statement because it doesn't change the state of the program.">statement</a> doesn't print anything.</p>
<h5 id="generics-type-checks-and-casts">Generics type checks and casts</h5>
<p>In Kotlin, we can use type checks and casts with generics as well. When working with generics, we may need to check whether an object is an instance of a specific type parameter or cast it to a <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a type parameter is a named type that is used in a class, interface, or function declaration to make it work with different data types. | Type parameters are often used in generic programming, which allows for versatility and reusability of code. They are typically named using a single letter, such as T, E, K, or V, to distinguish them from regular class names. When creating an instance of a generic class, you need to provide a concrete type as a type argument, which can be inferred by the compiler if it's a standard type. Once the type argument is specified, you can invoke methods of the class using the provided type. If the class has multiple type parameters, you should specify them in order. Type parameters can be used as ordinary types inside the class body, such as a type for a field, constructor argument type, instance method argument, or return type.">type parameter</a>.</p>
<p>To check whether an object is an instance of a specific type parameter, we can use the <code class="language-kotlin">is</code> operator with the type parameter in angle brackets. For example:</p>
<pre><code class="language-kotlin">fun &lt;T&gt; exampleFunction(obj: Any) {
    if (obj is T) {
        // obj is an instance of type parameter T
    } else {
        // obj is not an instance of type parameter T
    }
}</code></pre>
<p>Similarly, we can cast an object to a type parameter using the <code class="language-kotlin">as</code> operator with the type parameter in angle brackets. However, if the object is not an instance of the type parameter, <code class="language-kotlin">ClassCastException</code> will be thrown. To avoid this, we can use the safe cast operator <code class="language-kotlin">as?</code>, which returns <code class="language-kotlin">null</code> if the cast is not possible.</p>
<pre><code class="language-kotlin">fun &lt;T&gt; exampleFunction(obj: Any) {
    val tObj: T? = obj as? T
    if (tObj != null) {
        // obj can be safely cast to type parameter T
    } else {
        // obj cannot be cast to type parameter T
    }
}</code></pre>
<p>It's important to note that type erasure occurs with generics in Kotlin, meaning that the <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an actual is a keyword used in the context of property delegation. | It is used to specify the implementation of a property in a subclass when the property has been declared as abstract or open in the superclass. The actual keyword ensures that the subclass provides a concrete implementation for the property, preventing any ambiguity or errors related to property overriding. It is a way to enforce that subclasses adhere to certain requirements or have initial values set for properties.">actual</a> type of a generic object is not known at runtime. Therefore, certain operations, like creating a new instance of a type parameter or checking if a type parameter is a subtype of another class, are not possible.</p>
<p>In summary, type checks and casts with generics in Kotlin can be done using the <code class="language-kotlin">is</code> and <code class="language-kotlin">as</code> operators with the type parameter in angle brackets, and the safe cast operator <code class="language-kotlin">as?</code> can be used to avoid <code class="language-kotlin">ClassCastException</code>s. However, certain operations may not be possible due to type erasure.</p>
<h5 id="conclusion">Conclusion</h5>
<p>In conclusion, type cast and smart cast are important features in Kotlin, which allow checking and casting objects to different types. They are useful when working with objects of different types and performing operations that require a specific type. Now let's move on to practice to better remember this topic.</p>
</div>